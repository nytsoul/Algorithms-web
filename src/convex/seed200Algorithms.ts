import { v } from "convex/values";
import { mutation } from "./_generated/server";

export const seed200Algorithms = mutation({
  args: {},
  handler: async (ctx) => {
    // Check if already seeded
    const existing = await ctx.db.query("algorithms").take(200);
    if (existing.length >= 50) {
      return { message: "Algorithms already seeded", count: existing.length };
    }

    const allAlgorithms = [
      // SEARCHING ALGORITHMS (1-10)
      {
        name: "Linear Search",
        slug: "linear-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Sequential search through array elements one by one",
        intuition: "Check each element until finding target or reaching end",
        pseudocode: "for i from 0 to n-1:\n    if arr[i] == target:\n        return i\nreturn -1",
        implementation: "function linearSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return i;\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(n)", worst: "O(n)" },
        spaceComplexity: "O(1)",
        applications: ["Unsorted data", "Small datasets"],
        advantages: ["Simple", "Works on unsorted data"],
        disadvantages: ["Slow for large data"],
        relatedAlgorithms: ["Binary Search"],
        difficulty: "Beginner",
        tags: ["search", "linear"],
        visualizationType: "array-sequential",
        researchReferences: ["Basic algorithm"],
      },
      {
        name: "Jump Search",
        slug: "jump-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Search by jumping ahead by fixed steps in sorted array",
        intuition: "Jump ahead by √n steps, then linear search in block",
        pseudocode: "step = sqrt(n)\nwhile arr[step] < target:\n    step += sqrt(n)\nlinear search from prev to step",
        implementation: "function jumpSearch(arr, target) {\n  const step = Math.sqrt(arr.length);\n  let prev = 0;\n  while (arr[Math.min(step, arr.length)-1] < target) {\n    prev = step;\n    step += Math.sqrt(arr.length);\n  }\n  for (let i = prev; i < Math.min(step, arr.length); i++) {\n    if (arr[i] === target) return i;\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(√n)", worst: "O(√n)" },
        spaceComplexity: "O(1)",
        applications: ["Sorted arrays"],
        advantages: ["Better than linear"],
        disadvantages: ["Requires sorted array"],
        relatedAlgorithms: ["Binary Search", "Interpolation Search"],
        difficulty: "Beginner",
        tags: ["search", "jump"],
        visualizationType: "array-jump",
        researchReferences: ["1960s"],
      },
      {
        name: "Interpolation Search",
        slug: "interpolation-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Improved binary search using value interpolation",
        intuition: "Estimate position based on value distribution",
        pseudocode: "pos = low + ((target - arr[low]) / (arr[high] - arr[low])) * (high - low)",
        implementation: "function interpolationSearch(arr, target) {\n  let low = 0, high = arr.length - 1;\n  while (low <= high && target >= arr[low] && target <= arr[high]) {\n    const pos = low + Math.floor(((target - arr[low]) / (arr[high] - arr[low])) * (high - low));\n    if (arr[pos] === target) return pos;\n    if (arr[pos] < target) low = pos + 1;\n    else high = pos - 1;\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(log log n)", worst: "O(n)" },
        spaceComplexity: "O(1)",
        applications: ["Uniformly distributed data"],
        advantages: ["Very fast on uniform data"],
        disadvantages: ["Bad on non-uniform data"],
        relatedAlgorithms: ["Binary Search"],
        difficulty: "Intermediate",
        tags: ["search", "interpolation"],
        visualizationType: "array-interpolation",
        researchReferences: ["W.W. Peterson (1957)"],
        yearIntroduced: 1957,
        inventor: "W.W. Peterson",
      },
      {
        name: "Exponential Search",
        slug: "exponential-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Search by exponentially increasing range then binary search",
        intuition: "Find range by doubling index, then binary search",
        pseudocode: "i = 1\nwhile i < n and arr[i] <= target:\n    i = i * 2\nreturn binarySearch(arr, i/2, min(i, n-1), target)",
        implementation: "function exponentialSearch(arr, target) {\n  if (arr[0] === target) return 0;\n  let i = 1;\n  while (i < arr.length && arr[i] <= target) i *= 2;\n  return binarySearch(arr, Math.floor(i/2), Math.min(i, arr.length-1), target);\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(log n)", worst: "O(log n)" },
        spaceComplexity: "O(1)",
        applications: ["Unbounded arrays"],
        advantages: ["Works on unbounded data"],
        disadvantages: ["Requires sorted array"],
        relatedAlgorithms: ["Binary Search"],
        difficulty: "Intermediate",
        tags: ["search", "exponential"],
        visualizationType: "array-exponential",
        researchReferences: ["Bentley & Yao (1976)"],
      },
      {
        name: "Fibonacci Search",
        slug: "fibonacci-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Uses Fibonacci numbers to divide array",
        intuition: "Divide array using Fibonacci numbers instead of halving",
        pseudocode: "Use Fibonacci numbers to determine split points",
        implementation: "function fibonacciSearch(arr, target) {\n  let fib2 = 0, fib1 = 1, fib = fib2 + fib1;\n  while (fib < arr.length) {\n    fib2 = fib1; fib1 = fib; fib = fib2 + fib1;\n  }\n  let offset = -1;\n  while (fib > 1) {\n    const i = Math.min(offset + fib2, arr.length - 1);\n    if (arr[i] < target) {\n      fib = fib1; fib1 = fib2; fib2 = fib - fib1; offset = i;\n    } else if (arr[i] > target) {\n      fib = fib2; fib1 = fib1 - fib2; fib2 = fib - fib1;\n    } else return i;\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(log n)", worst: "O(log n)" },
        spaceComplexity: "O(1)",
        applications: ["Large sorted arrays"],
        advantages: ["Only uses addition and subtraction"],
        disadvantages: ["Complex implementation"],
        relatedAlgorithms: ["Binary Search"],
        difficulty: "Intermediate",
        tags: ["search", "fibonacci"],
        visualizationType: "array-search",
        researchReferences: ["Kiefer (1953)"],
      },
      {
        name: "Ternary Search",
        slug: "ternary-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Divide array into three parts for searching",
        intuition: "Similar to binary search but divides into 3 parts",
        pseudocode: "mid1 = left + (right-left)/3\nmid2 = right - (right-left)/3\nCompare with mid1 and mid2",
        implementation: "function ternarySearch(arr, target, left = 0, right = arr.length - 1) {\n  if (right >= left) {\n    const mid1 = left + Math.floor((right - left) / 3);\n    const mid2 = right - Math.floor((right - left) / 3);\n    if (arr[mid1] === target) return mid1;\n    if (arr[mid2] === target) return mid2;\n    if (target < arr[mid1]) return ternarySearch(arr, target, left, mid1 - 1);\n    else if (target > arr[mid2]) return ternarySearch(arr, target, mid2 + 1, right);\n    else return ternarySearch(arr, target, mid1 + 1, mid2 - 1);\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(log₃ n)", worst: "O(log₃ n)" },
        spaceComplexity: "O(log n)",
        applications: ["Unimodal functions"],
        advantages: ["Finds peaks in unimodal functions"],
        disadvantages: ["More comparisons than binary"],
        relatedAlgorithms: ["Binary Search"],
        difficulty: "Intermediate",
        tags: ["search", "ternary"],
        visualizationType: "array-search",
        researchReferences: ["Optimization technique"],
      },
      {
        name: "Unordered Sequential Search",
        slug: "unordered-sequential-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Sequential search on unordered data",
        intuition: "Linear search variant for unordered arrays",
        pseudocode: "for each element:\n    if element == target: return index",
        implementation: "function unorderedSequentialSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return i;\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(n)", worst: "O(n)" },
        spaceComplexity: "O(1)",
        applications: ["Unordered data"],
        advantages: ["Simple", "No sorting required"],
        disadvantages: ["Slow"],
        relatedAlgorithms: ["Linear Search"],
        difficulty: "Beginner",
        tags: ["search", "sequential"],
        visualizationType: "array-sequential",
        researchReferences: ["Basic algorithm"],
      },
      {
        name: "Ordered Sequential Search",
        slug: "ordered-sequential-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Sequential search with early termination on sorted data",
        intuition: "Stop when current element exceeds target",
        pseudocode: "for each element:\n    if element == target: return index\n    if element > target: return -1",
        implementation: "function orderedSequentialSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return i;\n    if (arr[i] > target) return -1;\n  }\n  return -1;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(n)", worst: "O(n)" },
        spaceComplexity: "O(1)",
        applications: ["Sorted data with early exit"],
        advantages: ["Can terminate early"],
        disadvantages: ["Still O(n) worst case"],
        relatedAlgorithms: ["Linear Search"],
        difficulty: "Beginner",
        tags: ["search", "sequential", "sorted"],
        visualizationType: "array-sequential",
        researchReferences: ["Basic algorithm"],
      },
      {
        name: "Hash-based Search",
        slug: "hash-based-search",
        category: "Search",
        domain: "Data Structures & Algorithms",
        description: "Search using hash table for O(1) lookup",
        intuition: "Use hash function to directly access element",
        pseudocode: "hash = hashFunction(target)\nreturn hashTable[hash]",
        implementation: "function hashSearch(hashTable, target) {\n  const hash = hashFunction(target);\n  return hashTable[hash] !== undefined ? hashTable[hash] : -1;\n}\n\nfunction hashFunction(key) {\n  return key % hashTable.length;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(1)", average: "O(1)", worst: "O(n)" },
        spaceComplexity: "O(n)",
        applications: ["Fast lookups", "Caching"],
        advantages: ["Very fast average case"],
        disadvantages: ["Requires extra space", "Hash collisions"],
        relatedAlgorithms: ["Binary Search"],
        difficulty: "Intermediate",
        tags: ["search", "hash", "data-structure"],
        visualizationType: "hash-table",
        researchReferences: ["Hash table concept"],
      },

      // SORTING ALGORITHMS (11-25)
      {
        name: "Selection Sort",
        slug: "selection-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Select minimum and swap with first unsorted element",
        intuition: "Find smallest, place at beginning, repeat",
        pseudocode: "for i from 0 to n-1:\n    min_idx = i\n    for j from i+1 to n:\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    swap(arr[i], arr[min_idx])",
        implementation: "function selectionSort(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    let minIdx = i;\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[minIdx]) minIdx = j;\n    }\n    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n²)", average: "O(n²)", worst: "O(n²)" },
        spaceComplexity: "O(1)",
        applications: ["Small datasets"],
        advantages: ["In-place", "Simple"],
        disadvantages: ["Quadratic time"],
        relatedAlgorithms: ["Insertion Sort"],
        difficulty: "Beginner",
        tags: ["sorting", "selection"],
        visualizationType: "array-swap",
        researchReferences: ["Folklore"],
      },
      {
        name: "Insertion Sort",
        slug: "insertion-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Build sorted array by inserting elements one by one",
        intuition: "Like sorting playing cards - insert each into correct position",
        pseudocode: "for i from 1 to n:\n    key = arr[i]\n    j = i - 1\n    while j >= 0 and arr[j] > key:\n        arr[j+1] = arr[j]\n        j--\n    arr[j+1] = key",
        implementation: "function insertionSort(arr) {\n  for (let i = 1; i < arr.length; i++) {\n    const key = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n)", average: "O(n²)", worst: "O(n²)" },
        spaceComplexity: "O(1)",
        applications: ["Small datasets", "Nearly sorted"],
        advantages: ["Stable", "Adaptive"],
        disadvantages: ["Quadratic worst case"],
        relatedAlgorithms: ["Selection Sort"],
        difficulty: "Beginner",
        tags: ["sorting", "insertion"],
        visualizationType: "array-insertion",
        researchReferences: ["Folklore"],
      },
      {
        name: "Counting Sort",
        slug: "counting-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Sort by counting occurrences of each element",
        intuition: "Count frequency of each element, then reconstruct sorted array",
        pseudocode: "count = array of zeros\nfor each element:\n    count[element]++\nreconstruct array from counts",
        implementation: "function countingSort(arr) {\n  const max = Math.max(...arr);\n  const count = new Array(max + 1).fill(0);\n  const output = new Array(arr.length);\n  \n  for (let i = 0; i < arr.length; i++) count[arr[i]]++;\n  for (let i = 1; i <= max; i++) count[i] += count[i - 1];\n  \n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i]] - 1] = arr[i];\n    count[arr[i]]--;\n  }\n  return output;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n + k)", average: "O(n + k)", worst: "O(n + k)" },
        spaceComplexity: "O(k)",
        applications: ["Integer sorting", "Small range"],
        advantages: ["Linear time", "Stable"],
        disadvantages: ["Only for integers", "Space overhead"],
        relatedAlgorithms: ["Radix Sort", "Bucket Sort"],
        difficulty: "Intermediate",
        tags: ["sorting", "counting", "non-comparison"],
        visualizationType: "counting-array",
        researchReferences: ["Seward (1954)"],
      },
      {
        name: "Radix Sort",
        slug: "radix-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Sort by processing individual digits",
        intuition: "Sort by least significant digit first, then move to more significant digits",
        pseudocode: "for each digit position from least to most significant:\n    use counting sort on that digit",
        implementation: "function radixSort(arr) {\n  const max = Math.max(...arr);\n  for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {\n    countingSortByDigit(arr, exp);\n  }\n  return arr;\n}\n\nfunction countingSortByDigit(arr, exp) {\n  const output = new Array(arr.length);\n  const count = new Array(10).fill(0);\n  \n  for (let i = 0; i < arr.length; i++) {\n    const digit = Math.floor(arr[i] / exp) % 10;\n    count[digit]++;\n  }\n  \n  for (let i = 1; i < 10; i++) count[i] += count[i - 1];\n  \n  for (let i = arr.length - 1; i >= 0; i--) {\n    const digit = Math.floor(arr[i] / exp) % 10;\n    output[count[digit] - 1] = arr[i];\n    count[digit]--;\n  }\n  \n  for (let i = 0; i < arr.length; i++) arr[i] = output[i];\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(d * (n + k))", average: "O(d * (n + k))", worst: "O(d * (n + k))" },
        spaceComplexity: "O(n + k)",
        applications: ["Large integer arrays", "String sorting"],
        advantages: ["Linear for fixed digits", "Stable"],
        disadvantages: ["Only for integers/strings", "Extra space"],
        relatedAlgorithms: ["Counting Sort", "Bucket Sort"],
        difficulty: "Intermediate",
        tags: ["sorting", "radix", "non-comparison"],
        visualizationType: "digit-sorting",
        researchReferences: ["IBM card sorting (1887)"],
      },
      {
        name: "Bucket Sort",
        slug: "bucket-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Distribute elements into buckets then sort each bucket",
        intuition: "Divide range into buckets, distribute elements, sort buckets individually",
        pseudocode: "create n empty buckets\nfor each element:\n    put element in appropriate bucket\nsort each bucket\nconcatenate all buckets",
        implementation: "function bucketSort(arr) {\n  if (arr.length === 0) return arr;\n  \n  const bucketCount = Math.floor(Math.sqrt(arr.length));\n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const bucketSize = Math.ceil((max - min + 1) / bucketCount);\n  const buckets = Array.from({ length: bucketCount }, () => []);\n  \n  for (let i = 0; i < arr.length; i++) {\n    const bucketIndex = Math.floor((arr[i] - min) / bucketSize);\n    buckets[bucketIndex].push(arr[i]);\n  }\n  \n  return buckets.flatMap(bucket => bucket.sort((a, b) => a - b));\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n + k)", average: "O(n + k)", worst: "O(n²)" },
        spaceComplexity: "O(n + k)",
        applications: ["Uniformly distributed data", "External sorting"],
        advantages: ["Linear on uniform data", "Parallelizable"],
        disadvantages: ["Bad on skewed data", "Extra space"],
        relatedAlgorithms: ["Radix Sort", "Counting Sort"],
        difficulty: "Intermediate",
        tags: ["sorting", "bucket", "distribution"],
        visualizationType: "bucket-distribution",
        researchReferences: ["E.J. Isaac & R.C. Singleton (1956)"],
      },
      {
        name: "Shell Sort",
        slug: "shell-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Generalized insertion sort with gap sequence",
        intuition: "Sort elements at large gaps first, reduce gap progressively",
        pseudocode: "gap = n/2\nwhile gap > 0:\n    insertion sort with gap\n    gap = gap/2",
        implementation: "function shellSort(arr) {\n  const n = arr.length;\n  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < n; i++) {\n      const temp = arr[i];\n      let j = i;\n      while (j >= gap && arr[j - gap] > temp) {\n        arr[j] = arr[j - gap];\n        j -= gap;\n      }\n      arr[j] = temp;\n    }\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n log n)", average: "O(n^1.25)", worst: "O(n²)" },
        spaceComplexity: "O(1)",
        applications: ["Medium-sized arrays", "Embedded systems"],
        advantages: ["Better than insertion sort", "In-place"],
        disadvantages: ["Unstable", "Gap sequence matters"],
        relatedAlgorithms: ["Insertion Sort", "Comb Sort"],
        difficulty: "Intermediate",
        tags: ["sorting", "shell", "gap"],
        visualizationType: "gap-insertion",
        researchReferences: ["Donald Shell (1959)"],
        yearIntroduced: 1959,
        inventor: "Donald Shell",
      },
      {
        name: "Tim Sort",
        slug: "tim-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Hybrid sorting algorithm derived from merge sort and insertion sort",
        intuition: "Use insertion sort for small runs, merge them efficiently",
        pseudocode: "divide into small runs\nsort runs with insertion sort\nmerge runs with merge sort",
        implementation: "function timSort(arr) {\n  const MIN_MERGE = 32;\n  const n = arr.length;\n  \n  for (let i = 0; i < n; i += MIN_MERGE) {\n    insertionSort(arr, i, Math.min(i + MIN_MERGE - 1, n - 1));\n  }\n  \n  let size = MIN_MERGE;\n  while (size < n) {\n    for (let start = 0; start < n; start += size * 2) {\n      const mid = start + size - 1;\n      const end = Math.min(start + size * 2 - 1, n - 1);\n      if (mid < end) merge(arr, start, mid, end);\n    }\n    size *= 2;\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n)", average: "O(n log n)", worst: "O(n log n)" },
        spaceComplexity: "O(n)",
        applications: ["Python's built-in sort", "Java's Arrays.sort"],
        advantages: ["Stable", "Adaptive", "Real-world optimized"],
        disadvantages: ["Complex implementation", "Extra space"],
        relatedAlgorithms: ["Merge Sort", "Insertion Sort"],
        difficulty: "Advanced",
        tags: ["sorting", "hybrid", "adaptive"],
        visualizationType: "hybrid-sorting",
        researchReferences: ["Tim Peters (2002)"],
        yearIntroduced: 2002,
        inventor: "Tim Peters",
      },
      {
        name: "Comb Sort",
        slug: "comb-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Improved bubble sort with gap sequence",
        intuition: "Use gap to eliminate turtles (small values at end)",
        pseudocode: "gap = n\nwhile gap > 1:\n    gap = gap / 1.3\n    bubble sort with gap",
        implementation: "function combSort(arr) {\n  const n = arr.length;\n  let gap = n;\n  let swapped = true;\n  \n  while (gap !== 1 || swapped) {\n    gap = Math.max(1, Math.floor(gap / 1.3));\n    swapped = false;\n    \n    for (let i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        [arr[i], arr[i + gap]] = [arr[i + gap], arr[i]];\n        swapped = true;\n      }\n    }\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n log n)", average: "O(n²/2^p)", worst: "O(n²)" },
        spaceComplexity: "O(1)",
        applications: ["Alternative to bubble sort"],
        advantages: ["Better than bubble sort", "Simple"],
        disadvantages: ["Unstable", "Not widely used"],
        relatedAlgorithms: ["Bubble Sort", "Shell Sort"],
        difficulty: "Beginner",
        tags: ["sorting", "comb", "gap"],
        visualizationType: "gap-bubble",
        researchReferences: ["Włodzimierz Dobosiewicz (1980)"],
      },
      {
        name: "Cycle Sort",
        slug: "cycle-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "In-place sorting by placing elements in correct positions",
        intuition: "Each element is placed in its final position in one cycle",
        pseudocode: "for each position:\n    place element in correct position\n    follow cycle until returning to start",
        implementation: "function cycleSort(arr) {\n  for (let cycleStart = 0; cycleStart < arr.length - 1; cycleStart++) {\n    let item = arr[cycleStart];\n    let pos = cycleStart;\n    \n    for (let i = cycleStart + 1; i < arr.length; i++) {\n      if (arr[i] < item) pos++;\n    }\n    \n    if (pos === cycleStart) continue;\n    \n    while (item === arr[pos]) pos++;\n    [arr[pos], item] = [item, arr[pos]];\n    \n    while (pos !== cycleStart) {\n      pos = cycleStart;\n      for (let i = cycleStart + 1; i < arr.length; i++) {\n        if (arr[i] < item) pos++;\n      }\n      while (item === arr[pos]) pos++;\n      [arr[pos], item] = [item, arr[pos]];\n    }\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n²)", average: "O(n²)", worst: "O(n²)" },
        spaceComplexity: "O(1)",
        applications: ["Minimum writes to memory"],
        advantages: ["Minimal writes", "In-place"],
        disadvantages: ["Quadratic time", "Unstable"],
        relatedAlgorithms: ["Selection Sort"],
        difficulty: "Intermediate",
        tags: ["sorting", "cycle", "minimal-writes"],
        visualizationType: "cycle-rotation",
        researchReferences: ["Haddon (1990)"],
      },
      {
        name: "Tree Sort",
        slug: "tree-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Sort using binary search tree",
        intuition: "Insert elements into BST, then in-order traversal",
        pseudocode: "for each element:\n    insert into BST\nin-order traversal of BST",
        implementation: "function treeSort(arr) {\n  const root = null;\n  for (let i = 0; i < arr.length; i++) {\n    root = insert(root, arr[i]);\n  }\n  const result = [];\n  inOrder(root, result);\n  return result;\n}\n\nfunction insert(node, value) {\n  if (node === null) return { value, left: null, right: null };\n  if (value < node.value) node.left = insert(node.left, value);\n  else node.right = insert(node.right, value);\n  return node;\n}\n\nfunction inOrder(node, result) {\n  if (node !== null) {\n    inOrder(node.left, result);\n    result.push(node.value);\n    inOrder(node.right, result);\n  }\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n log n)", average: "O(n log n)", worst: "O(n²)" },
        spaceComplexity: "O(n)",
        applications: ["Educational purposes"],
        advantages: ["Simple concept"],
        disadvantages: ["Can be unbalanced", "Extra space"],
        relatedAlgorithms: ["Heap Sort"],
        difficulty: "Intermediate",
        tags: ["sorting", "tree", "bst"],
        visualizationType: "tree-structure",
        researchReferences: ["Tree-based sorting"],
      },
      {
        name: "Odd–Even Sort",
        slug: "odd-even-sort",
        category: "Sorting",
        domain: "Data Structures & Algorithms",
        description: "Parallel sorting algorithm comparing odd-even pairs",
        intuition: "Alternate between comparing odd and even indexed pairs",
        pseudocode: "repeat until sorted:\n    odd phase: compare (1,2), (3,4), (5,6)...\n    even phase: compare (2,3), (4,5)...",
        implementation: "function oddEvenSort(arr) {\n  let sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (let i = 1; i < arr.length - 1; i += 2) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n        sorted = false;\n      }\n    }\n    for (let i = 0; i < arr.length - 1; i += 2) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n        sorted = false;\n      }\n    }\n  }\n  return arr;\n}",
        language: "JavaScript",
        timeComplexity: { best: "O(n)", average: "O(n²)", worst: "O(n²)" },
        spaceComplexity: "O(1)",
        applications: ["Parallel processing"],
        advantages: ["Parallelizable"],
        disadvantages: ["Quadratic time"],
        relatedAlgorithms: ["Bubble Sort"],
        difficulty: "Beginner",
        tags: ["sorting", "parallel", "odd-even"],
        visualizationType: "parallel-sort",
        researchReferences: ["Habermann (1972)"],
      },
    ];

    // Continue with remaining algorithms...
    // Total count should be 200
    // For now, adding core algorithms from each category

    const ids: string[] = [];
    for (const algo of allAlgorithms) {
      const id = await ctx.db.insert("algorithms", algo);
      ids.push(id);
    }

    return { message: `Successfully seeded ${ids.length} algorithms!`, count: ids.length };
  },
});
